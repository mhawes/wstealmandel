% ------------------------------------------------------------------------------
% includes preamble stuff
\input{pre}


% ------------------------------------------------------------------------------
% - Document starts here
% ------------------------------------------------------------------------------

\begin{document}

\input{title}

%setup initial roman numeral page numbering
\pagenumbering{Roman}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section*{Abstract}


% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\newpage
\section*{Acknowledgements}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\clearpage

% set numbering back to arabic
\pagenumbering{arabic}
\setcounter{page}{1}
\tableofcontents

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Introduction}

% Identify subject area and clearly state the arena of interest this report investigates.
    % * state of the field. 
    % * Talk about highly parallel computing and its applications. Be broad.

Multi-processor computers are now commonplace for both consumers and scientists alike, in replacement of uni-processors. 
This shift in architectural design demands a drastic shift in how programs for such platforms are constructed, 
from the standpoint of both the programmer and the language designer. 
Designing effective programs to utilise such hardware, using well established programming tools with sequential roots,
is often difficult and riddled with pitfalls. Popular languages such as C, Java, and C++ require a good knowledge of multi-threaded 
algorithms, as well as a deeper understanding of the problem domain to produce a highly effective design.
The programmer may be forced to sacrifice potential performance gain for a more manageable level of design complexity,
or worse still; avoid writing parallel code all-together in the interest of robustness.

Techniques to implicitly optimise run-time performance, with a minimum impact on complexity of parallel program design, 
are useful for more easily producing robust implementations. One aspect which allows for such optimisation is run-time work-load balancing.

This project explores a branch of load balancing techniques known as work-stealing. This is applied to an algorithm which
computes an approximation of the infinite mathematical set known as the Mandelbrot set.

\section*{Motivation}

The author has a strong interest in high performance computing and tools which provide powerful, abstract interfaces with 
underlying multi-processor architecture. Previous work on the Single Assignment C~\cite{sachome} and 
S-Net~\cite{snethome} programming languages has served to inspire, and further the desire for knowledge in the subject area.

This project is motivated by the aspiration to better understand how modern computer architectures can be optimally utilised,
and communicate these findings in a concise, comprehensive report.

In addition the author wishes to gain valuable experience of the project development and management process.

\section*{Aim}

To investigate, through research and practical implementation, the effectiveness of work-stealing on
a parallel algorithm which computes an approximation of the Mandelbrot set.

\section*{Objectives}
This section outlines the deliverable items that are presented in this report.
Core objectives are primary and more vital, advanced objectives are additional items.

\subsection*{Core Objectives}
\newcounter{saveenum}
\begin{enumerate}
\item \textbf{Background Research}
\item \textbf{A Sequential Mandelbrot Set Algorithm}
\item \textbf{A Na\"{\i}ve Parallel Mandelbrot Set Algorithm}
\item \textbf{A Random Work-Stealing Mandelbrot Set Algorithm}
\item \textbf{Analysis of the Implemented Algorithms}
\setcounter{saveenum}{\value{enumi}}
\end{enumerate}

\subsection*{Advanced Objectives}
\begin{enumerate}
\setcounter{enumi}{\value{saveenum}}
\item Graphical Output
\item A Render Thread Work-Stealing Mandelbrot Set Algorithm
\item Work-Stealing Trace System
\end{enumerate}

\section*{Achievements}
The following table shows each objective and its completion status at the time this
report was produced. 

\begin{table}[H]
    \centering
    \begin{tabular}{|r|l|}
        \hline
            \textbf{Objective} & \textbf{Status} \\
        \hline \hline
            \textbf{1} & Complete \\
            \textbf{2} & Complete \\
            \textbf{3} & Complete \\
            \textbf{4} & Complete \\
            \textbf{5} & Complete \\
        \hline
            6 & Complete \\
            7 & Partially Complete \\
            8 & Complete \\
        \hline
    \end{tabular}
    \label{tab:ach}
    \caption{Table of Achievements}
\end{table}

\section*{Report Structure}

There are five remaining chapters in this report. 
In chapter two a detailed review of the problem background is presented. 
Chapter three details the practical implementation, which this report is based on, and the manner in which it was carried out.
Chapter four offers an evaluation of the project as a whole. This includes analysis of the implemented software and a comparison of the implemented
schemes.
Chapter five lists the resources referenced in this report.

In chapter six the appendices are presented.
A glossary of terms is presented as Appendix \ref{sec:glosterm}. 
This consists of a list describing major concepts surrounding the field of study, and directs the reader to their pages of occurrence. 
Words emphasised in bold typeface indicate the first appearance of a glossary term.
The source code for all software developed to fulfil the objectives described above is presented as Appendix \ref{sec:srccode}.

% Identify some of the key pieces of literature or applications for the subject area I have chosen.
% This report identifies two contrasting work-stealing schemes and analyses their performance using an algorithm to
% compute an approximation of the Mandelbrot set as a case study. 

% Talk about the specific investigated area's and what the report specifically talks about.
    % * i.e. which work-stealing schemes are implemented, which Mandelbrot algorithm is identified.

% Rationale for doing above said things and aims of project.
% The work is carried out in order to establish an understanding of how effective run-time scheduling of parallel 
% computations is when considering load-balancing. 

% Disclaimer section i.e. This report assumes prior knowledge of blah blah blah and is written
%   with whomever in mind and so on.
% This report assumes some prior understanding of parallel algorithms.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Background Research}
\label{ch:backres}
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Run-Time Scheduling Techniques for Multi-Threaded Computations}
This section briefly describes the problems associated with \gls{scheduling} \glspl{multi-threaded algorithm} at run-time and
the major paradigms that have surfaced.

To efficiently utilise a parallel computer architecture it is desirable to minimise
the amount of time a processor spends idle or performing other logistical tasks, i.e not doing work. 
When a computation's concurrent sub-tasks (or \glspl{thread}) incur a regular cost in processor
time, each processor can simply have the same amount of work assigned to them. When the computation has
more irregular or dynamically growing sub-tasks, a problem arises resulting in 
processors becoming idle while others still remain working. The solution to this problem is referred to as
\gls{load-balancing} and can be described as a form of dynamic scheduling, that ensures each processor 
spends approximately the same amount of time working. This means processors generally spend
less time idle, however have to deal with scheduling overheads as a trade-off.

When considering the scheduling of multi-threaded computations, two major load balancing techniques have been used.
These are \gls{work-sharing} and \gls{work-stealing}.

\begin{itemize}
\item \textbf{Work-Sharing:} A processor which creates new work attempts to migrate it to another underutilised processor at creation time. 
\item \textbf{Work-Stealing:} A processor which is starved of work attempts to ``steal'' work from other processors. 
\end{itemize}

Both techniques intend to promote balanced work-load across all processors, however in Work-Stealing
the frequency of work migrations is lower. When all processors have a 
high work-load and no need to ``steal" this becomes useful because threads need not get 
migrated at all. With \gls{work-sharing} work migration occurs each time new work is created \cite{blumleis}.
This also suggests that \gls{work-stealing} promotes better \gls{locality} and grouping of sub-tasks, as spawned work 
stays with the same processor until stolen.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{The Mandelbrot Set}

The Mandelbrot set is a set of complex numbers which when plotted produce a spectacular and recognisable shape as illustrated in figure~\ref{fig:mandelimg}.
It is often presented as a colourful and striking image and has been described by some as the most beautiful object in all of mathematics 
\cite[p.~234]{chaosfract}.
The \glspl{complex-number} that comprise the set are closely related to julia-sets. 
In-fact the Mandelbrot set can be described as a catalogue of Julia Sets which, when plotted, all points are connected 
forming a single unbroken shape \cite[p.~177]{fractimg}.

The set is named for the mathematician Benoit Mandelbrot, who discovered it in 1980 \cite{fracnature , fractimg}. He was a pioneer in the study of 
fractal geometry and also coined the term \gls{fractal}, of which both the Mandelbrot set, and Julia sets are examples of. 

In this section I will give a more detailed explanation of the areas mentioned here. 

\begin{figure}[h]
  \caption{A rendering of The Mandelbrot Set generated using the program ``fraqtive"\cite{fraqtive}.}
  \label{fig:mandelimg}
  \centering
    \includegraphics[width=1\textwidth]{mandelbrot}
\end{figure}

\subsection*{Fractals and Self-Similarity} 
A \gls{fractal} is a means of describing shapes which are more complex than a Euclidean shape. The leaves of a pine tree or the forks of a 
lightning bolt are obvious examples of real things that fractals allow us to more faithfully describe. 
These \glspl{real-world-fractal} are similar to \glspl{mathematical-fractal}, 
of which the Mandelbrot set is an example, but differ in that they do not display the property of \gls{scale-invariance}. 

Fractals have a fractional dimension. Unlike shapes with topological dimension, for instance a two dimensional square, 
a \glspl{fractal} dimension is of a non integer value.

A property of fractals (but not all) is \gls{self-similarity}, where the shape is comprised of smaller ``copies" of itself. 
This is known as \gls{exact self-similarity} and means the shape is identical at any scale.
A well-known example of this is the Triadic Koch Snowflake which is a fractal constructed using equilateral triangles. 
It is important to note here that The Mandelbrot set does not quite show the same property, it is said to be 
\glspl{quasi self-similarity}. This means the shape is approximately similar at all scales, in that the shape is replicated but in a slightly distorted
form with each ``copy".

It turns out there are many rather useful applications for fractals. To name a few; 
computer graphics used in video games and film (notably Star Trek II: The Wrath of Khan \cite[p.~8]{fractimg}), 
military hardware design \cite{fractantenna}, and measuring the length of a coastline \cite{coastline}.

\subsection*{Julia Sets}

To understand the basis of the Mandelbrot set it is first necessary to understand it's relation to julia-sets.
The function in equation~\ref{eq:julia1} is iterated infinitely where \(c\) is fixed.
The filled julia-set is comprised of all values of \(z_0\) where the result is bounded and does not tend towards infinity.
The julia-set is comprised of those members of the filled julia-set which lie on the boundary \cite{chaosfract}.
In the interest of keeping this report readable, and because filled Julia Sets are more relevant, filled julia-sets will be 
referred to simply as julia-sets.

\begin{equation}\label{eq:julia1}
f(z) = z^2 + c
\end{equation}

The Mandelbrot Set is related to julia-sets in which the values \(c\) and \(z\) used are expressed as a 
\gls{complex-number}. Figure~\ref{fig:juliaimgs} illustrates some examples of such sets. 

\begin{figure}[h]
\centering
\begin{subfigure}[b]{0.48\textwidth}
  \centering    
  \includegraphics[width=\textwidth]{julia-con}
  \caption{
    \tiny The julia-set where \(c = -0.1 + 0.649i\)
  }
  \label{fig:juliaimgcon}
\end{subfigure}
~ %spacer
\begin{subfigure}[b]{0.48\textwidth}
  \centering
  \includegraphics[width=\textwidth]{julia-ncon}
  \caption{
    \tiny The julia-set where \(c = -0.75 + 0.03i\)
  }
  \label{fig:juliaimgncon}
\end{subfigure}
% full caption
\caption{
  Two Julia Sets rendered using the program ``fraqtive"\cite{fraqtive}. 
  Figure~\ref{fig:juliaimgcon} is a member of the Mandelbrot set, 
  figure~\ref{fig:juliaimgncon} is not.
}
\label{fig:juliaimgs}
\end{figure}

\subsection*{Computing the Mandelbrot Set}

The set is comprised of those julia-sets which are connected. In order to determine whether a Julia Set possesses this property,
we need only compute the result for \(z_0\). If this tends towards infinity the value \(c\) is not a member of the Mandelbrot Set. If the result
is bounded, then it is a member. This is known as the \gls{critical-orbit} and is useful because it means we do not have to compute
the entire Julia Set for each value of \(c\).

So the Mandelbrot set can be computed by iterating all possible values of \(c\) for the function in equation~\ref{eq:julia1} where \(z\) is the 
\gls{critical-orbit}. Because the set of all possible values of \(c\) is infinite, and computers have a finite amount of resources, this 
set needs to be approximated. This can be done using a raster plane which takes samples of the complex plane at regular intervals. 

There are many algorithms including the Level set method \cite[p.~188]{fractimg} and Continuous Potential Method \cite[p.~191]{fractimg}.
The former uses a raster plane to produce an approximation as described above, and the latter produces a smooth surface representation.
\\

\begin{lstlisting}[label = li:mandelalgo, caption = A sequential algorithm to compute the Mandelbrot Set]
compute_mandelbrot()
    FOR y = 0 TO height - 1 DO
        c_im := im_min + y * (im_max - im_min)/(height - 1)
        FOR x = 0 TO width - 1 DO
            c_re := re_min + x * (re_max - re_min)/(width - 1)
            output_plane[x][y] := level_set(c_re,c_im,max_iterations)
        END FOR
    END FOR
END

level_set(c_re,c_im,max_iterations)
    z_re := c_re
    z_im := c_im

    FOR i = 0 TO max_iterations DO
        IF( z_re^2 + z_im^2 > 4) THEN
            RETURN i
        END IF
        
        tmp_im = 2 * z_re * z_im + c_im
        z_re := z_re^2 - z_im^2  + c_re
        z_im := tmp_im
        
    END FOR
    RETURN max_iterations
END
\end{lstlisting}

Listing \ref{li:mandelalgo} describes a variation of the level set method in pseudo code. 
The algorithm is simple and provides a gradient effect of equipotential curves on the output image
which is visually pleasing.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{The Work-Stealing Technique - Described in Depth}
\label{sec:resworkdepth}

As described above, \gls{work-stealing} is a \gls{load-balancing} technique which allows work starved processors to acquire scheduled work from other processors. 

Each processor has a number of assigned tasks to complete. In general, a processor acquires its work from here.
However, once these tasks are exhausted, the processor becomes a \gls{thief} and a \gls{victim} is chosen to steal from. 
The method used to choose a victim is implementation specific, for instance some implementations adopt a random scheme \cite{blumleis , jliff, narora}.
If the processor successfully steals work it relinquishes its thief state and returns to doing work.
If the steal attempt is unsuccessful, for instance when the victim has no work or is blocked, the processor tries again
until it is determined that there is no work remaining in the entire network. 

Figure~\ref{fig:stealoperation} illustrates the result of a successful steal operation in which work-starved processor \textit{p1} transfers a piece
of work from \textit{p0's} work list to its own. %do more here.

\begin{figure}[h]
\centering
\begin{subfigure}[b]{0.4\textwidth}
  \centering    
%  \includegraphics[width=\textwidth]{stealreq}
  \include{./imgs/stealreq}
  \caption{
    \tiny A steal request by the thief processor \textit{p1} on victim \textit{p0}.
  }
  \label{fig:stealreq}
\end{subfigure}
~~~~~~ %spacer
\begin{subfigure}[b]{0.4\textwidth}
  \centering
%  \includegraphics[width=\textwidth]{stealafter}
  \include{./imgs/stealafter}
  \caption{
    \tiny The attempt was successful and the work was re-assigned to \textit{p1}.
  }
  \label{fig:stealsuccess}
\end{subfigure}
\caption{
    A successful steal operation between a thief and its victim.
  }
\label{fig:stealoperation}
\end{figure}

Research has been conducted to explore its application in programming languages such as Cilk \cite{blumleis}, 
parallel programming libraries such as Hood \cite{hoodlib} and Factory \cite{factorylib}, 
and large scale heterogeneous systems such as computational clouds \cite{scalesthesis}.

This section explores some schemes used to implement work-stealing in various settings. It is focused on overall design and 
techniques presented in related literature. 

\subsection{Blumofe and Leiserson - A Randomized Work-Stealing Algorithm}
\label{sec:randscheme}

This scheme is geared towards computation of dynamically growing, fully strict, multi-threaded computations and is applied to the CILK
programming language and its runtime system \cite{blumleis}. 

Each thread maintains a \gls{ready-deque}; a double-ended queue of work waiting to be processed. 
Accesses to this queue are made either at the top (for a steal operation), or at the bottom (for a push operation
or when the next piece of work is required).
A thread becomes a \gls{thief} when its ready-deque is empty and randomly selects a \gls{victim}; a thread
to attempt to steal work from. If this \gls{steal-operation} is successful it pushes the stolen work 
onto the bottom of its ready-deque and becomes a worker again. If not it tries, at random, to find another victim.

The ready-deque can be implemented in such a way that a thread need not be stopped in order for a steal operation 
to occur. This property is known as \gls{non-blocking} and only requires that the top end of the deque has atomic access,
while the bottom can freely be accessed by the thread which owns the deque \cite{narora}. This is useful because it reduces the overheads 
of a steal operation in that a working thread generally does not get interrupted. 
Further still, a non-blocking deque can be made more efficient through use of a \gls{circular array} \cite{circdeque}.

Because of the setting this scheme is designed with in mind, the algorithm needs to consider that
a piece of work can spawn children dynamically, which it may depend on completing to continue. 
When computing the Mandelbrot set in a concurrent environment, no such consideration is required 
as each point can be independently processed.

\subsection{McGuiness - Render-Thread Algorithm}
\label{sec:rendscheme}

This scheme is presented as part of McGuiness' Masters Thesis \cite{jmcguin}, and is suited for parallel computation where each unit of work is independent 
from any other and can be indexed in a list. Computation of the Mandelbrot set is given as an application of the algorithm. 

The algorithm uses a set of \glspl{worker-thread} (referred to by McGuiness as render-threads), 
and a single \gls{monitor-thread}, to control the distribution of work. Each \gls{worker-thread} is
initially given an equal share of the overall work-load before starting.

Each \gls{worker-thread} maintains an estimated completion time for its assigned work-load. This is initially set to the maximum possible value and
is iteratively refined by calculating the average time taken to complete a piece of work. This metric is used as a policy for deciding which
thread is the most suitable candidate for the victim of a work-stealing operation.

When a worker-thread completes its assigned work a work-completed signal is generated, its estimated
completion time is set to \textit{0}, and the thread is stopped. This thread will be referred to as the \gls{thief}.
When the monitor thread detects this signal, it searches for the worker-thread with the longest estimated completion time, 
which will be referred to as the \gls{victim}. The \gls{monitor-thread} waits for the victim to complete its current piece of work before stopping it.
Its workload is then halved, having the other half re-asigned to the thief. Both the victim and the thief are restarted and continue doing work.
The monitor-thread returns to waiting for another work-completed signal and the process is repeated until no work remains.


% --------------------------------------------------------- HYPOTH section????? FIXME 
\subsection*{Discussion of the Presented Schemes}
The key difference between the Render-Thread Algorithm and the Randomized Work-Stealing Algorithm 
is that a \gls{worker-thread} does not maintain a queue of work, but simply has a range of indices assigned. 
This all but eliminates the overheads associated with initialising and 
maintaining a potentially costly data-structure, but makes a \gls{non-blocking} implementation difficult. It also requires a monitor-thread to manage
work migration which reduces the maximum number of threads performing work by one. 
Another limiting factor is that only one thread may perform work-stealing at any given time. The Randomized Work-Stealing Algorithm has no such limitation.

% Talk about scalability. i.e. the average estimated completion time vs randomly selected of victim


% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Tools}
\label{sec:restools}

This section discusses some of the programming and general tools which were considered
for use in the implementation and for the good of the project as a whole.
The tools discussed in this section are all viable options for a Linux platform.

\subsection*{Programming Languages}

\begin{itemize}
\item \textbf{C:} 
            A general purpose imperative language which is very widely used.
            It is statically typed but weakly enforces type errors and allows low level access to memory, which 
            makes the programmer responsible for reclaiming used memory.
            This allows the programmer a high level of control but reduces type safety.
            It is not object oriented and lacks many features of more modern high level
            language features.
            
            C is well suited for implementing efficient, high performance programs due to
            its relatively low level of abstraction compared to more modern languages.
            It is often associated with system programming because of this.
            A number of parallel programming libraries are available amongst other useful 
            libraries.
            
            GCC is an open source, industry standard compiler and is freely available. 
            It is well documented and supported.

\item \textbf{C++:}
            A general purpose multi-paradigm language inspired by C.
            C++ adds object oriented programming (amongst other features) to the majority 
            of C's syntax and features. 
            This makes it more suitable for implementing larger application systems 
            with the same benefits of low-level memory manipulation that C boasts.
            
            Some useful features include inheritance of types, dynamic polymorphism, 
            and templates (including an extensive library of useful template classes).
            A number of parallel programming libraries are available and are similar 
            if not the same as the equivalent C versions.
            
            G++ is a variant of the GCC compiler and shares a number of its properties.
            
\item \textbf{Java:}
            Primarily an object oriented language which borrows features from other paradigms.
            It is highly portable because it targets java bytecode which runs on the java virtual machine, available on most platforms.
            It is heavily influenced by C and C++ but offers few low-level facilities available in said languages. 
            For instance pointers are not available and a garbage collector is used to move
            the responsibility of memory management from the programmer, to the run-time system.
            Although this is a useful tool, the consequence is a considerable run-time overhead.
            
            Java is more suited to application programming than the likes of C and C++.
            Its extensive API offers concurrent programming classes.
            
            An open source compiler suite is available as well as a propriety version. 
            These are both widely used and well documented.
\end{itemize}

\subsection*{Parallel Programming Libraries}
In order to implement Work-Stealing, support for programming threads 
with a suitable level of control is required.

\begin{itemize}
\item \textbf{POSIX Threads (pthreads):} \\ 
              Provides low level manipulation of threads for the C programming language \cite{pthreadover}. 
              It is a library based on IEEE standard 1003.1. Thread programming is achieved by 
              specifying a function in which to run in parallel.
              Thread synchronisation is supported through use of a set of functions and data
              structures provided; such as \glspl{mutex}, \glspl{barrier}, and \glspl{condition-variable}. 
             
\item \textbf{Open Multiprocessing (OpenMP):} \\ 
              Provides abstract thread programming interfaces for C, C++, and fortran.
              In general OpenMP only allows coarse grained manipulation of threads through features such as parallel loops 
              \cite{ompvspthr}.

\item \textbf{Java Threads:} \\
              An object oriented approach to multi-threaded programming. Java provides a Thread class which
              the programmer can specialise to perform the desired task.
              Synchronisation is generally done using implicit locks through use of the synchronised modifier.
\end{itemize}

\subsection*{Graphical Output}
For the purpose of demonstrating that the program correctly generates a raster plane
of the Mandelbrot set, a graphical representation of the plane is output.

\begin{itemize}
\item \textbf{PPM Output File:} \\
              The simplest option is to output to a Portable Pixel Map (PPM) file. It is 
              text-file based and easy to implement but produces rather large files. 
              The process of outputting to a text file is inherently serial in nature,
              so with large image resolutions processing takes a long time.
              There is support for both grey-scale (Portable Grey-scale Map format) and colour images. 
              The advantage of using this method is the portability. No libraries or extras are required
              and most image viewers will read the file. \cite{ppmspec}
              
\item \textbf{GNU Plot:} \\
              A graph plotting package available for multiple operating systems. 
              Supports screen display or file output of both 2d and 3d graphics \cite{gnuplot}.
              There are programming interfaces available for various languages such as C \cite{gnuplotcint}, C++ \cite{gnuplotcppint}, 
              and Java \cite{gnuplotjint}.
              GNU Plot needs to be installed on the machine in order to use it.
              
\item \textbf{OpenGL - glut:} \\
              Glut is a framework for providing simple, cross-platform, GUI window control in conjunction
              with OpenGL. Bindings are available for various languages, including C and C++ \cite{openglglut}.
              A free implementation called ``freeglut" is available and can be installed on linux \cite{freeglut}.
              This method requires OpenGL and an implementation of Glut be available on the machine that the program 
              is run on.
              
\end{itemize}


% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
%\chapter{Main Sections}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{The Implementation}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{General Design and Practices}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection*{Development Process Model}

% Try writing about feature driven development and see if it turns out better....
A feature driven development (FDD) style approach to development is adopted for this project. 
FDD is a branch of project management derived from the school of agile process models \cite{pracguidefdd}. 
It is almost ideal for this project due to the small scale,  short product life-cycle,
and the flexibility needed when requirements change as the project transpires.
\\

\input{fddmodel}

Some of the notable features of FDD which make it attractive for such a project are described 
as follows:

\begin{itemize}
\item Short, iterative cycles of development.
\item Working results delivered by each iteration.
\item Flexibility for developers and clients alike, allowing for easy adaptation to changing requirements.
\item Product quality is emphasised at each step. 
\item Development stages may overlap, i.e. individual features can be produced concurrently.
\end{itemize}


% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection*{Major Tool Choices}

The implementation is realised using the C programming language, the pthreads library, and PPM files for graphical output.
These choices are based on the tools examined in section \ref{sec:restools}.

The C programming language is chosen for its relatively low-level of abstraction and level of control over memory management\footnote{
This decision is contrary to the choice (i.e. C++) documented in the project proposal.}.
It is preferable over C++ and Java because features such as object oriented programming are deemed unnecessary run-time overheads.
The implementation is relatively small-scale, so C will suffice in terms of managing the code complexity.

The pthreads library is selected for its low-level control compared to the likes of OpenMP and Java Threads.
The implementation of the Randomised Work-Stealing algorithm only requires control of simple thread synchronisation (i.e. mutexes)
and nothing more. 

The text based PPM file format is chosen for its simplicity and portability. Producing a graphical representation of the Mandelbrot set is not
the primary purpose of this project, but is still a desirable feature for verification and demonstration purposes.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsubsection*{Other Tools Used}

Listed here are the major utility tools which have been used to make this project of a better over-all 
quality. 

\begin{itemize}
\item \LaTeX: \\   
            A document preparation mark-up language which produces professional and consistent 
            documents. 

\item \textbf{GNU Make:} \\ 
            A tool to aid quick and easy building of a project. It uses a series of 
            rules and dependencies to determine the order in which a project can be built, 
            which are described in an accompanying Makefile. 
                         
            This is useful for  producing an executable from source code, as well
            as compiling a \LaTeX~document in conjunction with bibtex to produce a pdf.

\item \textbf{Git:} \\     
            A distributed version control system which provides version tracking capabilities. 
            It has the benefit of providing a means of backing up, as-well as maintaining 
            synchronisation of project files across multiple machines.
            It also serves to document the progress of a project through commit messages.
\end{itemize}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection*{Coding Conventions}

All presented code follows strict conventions to ensure readability. Following is a list of conventions used.
\begin{itemize}
\item \textbf{Names: } \\
            All variable and function names are given in lower-case with multiple words separated by an underscore.
            Function names declared in a module are prefixed with an associated acronym. For instance, functions declared in 
            `deque.c' start with `de\_'.
            Type definitions are named in the same fashion as a variable, followed by a trailing `\_t', to match the style used 
            by the pthreads library.
            
\item \textbf{Parentheses: } \\
            For functions and iteration statements the opening parenthesis is placed on a new line, in any other case it
            can be placed on the same line. The closing parenthesis is always placed on its own line.
                        
\item \textbf{Constants and Pre-Processor Directives: } \\
            Pre-processor directives are declared in the accompanying header file. All names are in upper-case
            with words separated by an underscore.
\item \textbf{Commenting} \\
            Comments are used to describe code sections which are challenging to understand or 
            where complicated constructs are used. 
            Where code is simple enough to be self documenting comments are used sparingly.
            In general the block style is used (i.e. /{}* ... *{}/).
\end{itemize}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection*{Modular Design}

The implementation takes the form of a modular design. The module which has the functionality to compute the Mandelbrot set
has an interface to which a separate `scheduling' module can be attached. The Makefile holds a rule for each scheduling 
module and builds a binary for each. This approach provides several benefits. 

\begin{itemize}
\item It ensures all scheduling modules use exactly the same scheme to compute the Mandelbrot set, making them more comparable.
\item It allows for a common user-interface for each executable, independent of the scheduler back-end.
\item It allows for alteration to the mandelbrot module to be made with ease.
\end{itemize}

%\subsubsection*{Useful Language Features}

% TODO
% talk about the static keyword in C for the array.
% talk about inlining some functions
% Describe ppm output

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{An Algorithm to Compute the Mandelbrot Set}
\label{sec:mandmod}

This section describes the Mandelbrot module, which provides an interface for run-time scheduler implementations to 
compute a raster-plane of the Mandelbrot set line by line. 
This interface is provided primarily by the compute\_line function. 
The module requires that any attached scheduler module implements the functions
ws\_initialise\_threads and ws\_start\_threads. 
The former should be used for any set-up (e.g initialising global variables),
and the latter is used to start processing the raster plane.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection{The Mandelbrot Module}

The key functions used in the mandelbrot module are described as follows:

\begin{itemize}
\item \textbf{compute\_line:} \\
            Iterates a single line of the \(x\) axis on the raster plane, specified by a parameter \(y\), and assigns the result to the corresponding
            members of the plane matrix.
            It also accepts a `t\_id' (thread id) parameter, which is used for visualising regions of work completed per thread.
            This is used as a point of interface for the attached scheduler module, which is responsible for iteration of the \(y\) axis. 
            The implication of this design means that the minimum granularity of a work item
            is one `line'.

            The function converts the co-ordinates \(x\) and \(y\) into a corresponding complex number \(c\) using the converte\_x\_coord and 
            convert\_y\_coord functions respectively. 
            Should the value of \(c\) lie outside the radius of two from the origin, the point is 
            assigned the constant PPM\_BLACK. Its thread id is assigned WORKER\_COUNT to indicate to indicate that the graphical output should
            ignore any thread information for this pixel.
            Otherwise the pixel is assigned the value returned from the is\_member function and the thread id is assigned the value of 
            the t\_id parameter.
            
\item \textbf{is\_member:} \\
            Returns a value between 0 and the constant MAX\_ITERATIONS. It accepts a complex number \(c\) which corresponds to one point 
            on the complex plane and one pixel of the raster plane. This function determines (approximately) whether point \(c\) tends towards
            infinity.
            
            The variable \(z\) is initially assigned the value of \(c\). The function iterates until either the MAX\_ITERATION count is reached
            or \(\sqrt z_r^2 + z_i^2 > 2\), which is simplified to \(z_r * z_r + z_i * z_i > 4\) to avoid the `sqrt' function for efficiency
            reasons. The former condition indicates that \(c\) is a member of the set and a constant to indicate this is returned. 
            The latter indicates that \(c\) is not a member of the set and the number of iterations is returned, which produces a gradient 
            effect on the output image. At the end of each iteration the next value of \(z\) is obtained by calling the julia\_func function,
            passing the current value of \(z\) and the value of \(c\).
            
\item \textbf{julia\_func:} \\
            Computes the function shown in equation~\ref{eq:julia1}. It accepts two complex numbers; \(z\) and \(c\).
            
            The returned complex number is calculated by the following two expressions;
            for the imaginary part \(res_i = 2 * z_r * z_i + c_i\) and for the real part \(res_r = (z_r * z_r) - (z_i * z_i) + c_r\).

\item \textbf{convert\_y\_coord} and \textbf{convert\_x\_coord:} \\
            Collectively converts a coordinate of the raster plane into its corresponding point on the complex plane.
            The convert\_y\_coord returns the imaginary part and the convert\_y\_coord returns the real part.
            Both return a double type.
            The two are separated to avoid unnecessary conversion of the \(y\) coordinate in the compute\_line function,
            as this only need occur once per `line'.
\end{itemize}

The algorithm is based on the level set method \cite[p.~188]{fractimg}.
It is optimised slightly by checking that the point is not outside the radius of two before 
calling the is\_member function. This is because no member of the set lies outside this radius
thus saving us iterating for such a point unnecessarily.  

% the raster plane images.
\input{rastereg}

Each pixel of the raster plane maps to a point on the complex plane. Figure \ref{fig:rasterdemo} demonstrates
this. 

Several parameters are used by the algorithm to construct the raster plane.

\begin{itemize}
\item \textbf{HEIGHT} and \textbf{WIDTH:} \\
            Constants which define the dimensions of the raster plane i.e the maximum values of
            \(y\) and \(x\) respectively.
            
            
\item \textbf{MAX\_ITERATIONS:} \\
            A constant iteration limit which is used to determine if a point lies within the set.
            This is used by the is\_member function.
            
\item \textbf{The c\_max} and \textbf{c\_min:} \\
            Complex numbers which define the limits of the complex plane of
            which the raster plane samples.

\item \textbf{The c\_factor:} \\
            A complex number which determines the difference between a sampled point 
            of the complex plane, and an adjacent sample.
            It is calculated using the dimensions of the raster plane, and the 
            minimum and maximum values of c.
            \[ cfactor_r = cmax_r - cmin_r / rasterwidth - 1 \]
            \[ cfactor_i = cmax_i - cmin_i / rasterheight - 1 \]            
\end{itemize} 

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{A Randomised Work-Stealing Algorithm}
\label{sec:randws}

%to cover:
% * Describe the non-blocking deque implementation. The top mutex, non-blockingness, circular array design, shrinking-growing
% * architecture of algorithm: UML diagrams, describe key choices i.e. how much work is stolen. 
% * Describe how the algorithm starts and detects completion of thread i.e. initial distribution, exclude set.

This section describes the implementation of the Randomised Work-Stealing algorithm based on the scheme described in section \ref{sec:randscheme}.
This implementation uses four threads, each maintaining its own \gls{ready-deque}. The implemented \gls{ready-deque} is based on
the scheme presented in \cite{circdeque}.

\subsection{The Deque Implementation}
\label{sec:dequeimp}

% general description
Three key operations are made on a \gls{ready-deque}. These are de\_pop\_bottom, de\_push\_bottom, and de\_steal.

\begin{itemize}
\item \textbf{de\_pop\_bottom: } \\
                         Accepts a Deque pointer and returns a Line from the front of the deque, or a Line signalling an empty Deque.
                         
                         The bottom counter of the Deque passed to the function is decremented regardless of the outcome.
                         If the deque is empty a Line with a status of LINE\_EMPTY is returned, 
                         expecting the client code to handle this appropriately. 
                         If the Deque has more than one item, it may be shrunk and the Line indexed using the bottom counter is returned.
                         If the Deque only holds one item and the top\_mutex is locked, then a simultaneous steal operation has claimed
                         the last item. In this case a Line with a status of LINE\_EMPTY is returned. 
                         Otherwise the remaining bottom item is returned.

\item \textbf{de\_steal: } \\
                         Accepts a Deque pointer and attempts to return a Line from the back of the deque. Otherwise a Line with 
                         status LINE\_EMPTY or LINE\_ABORT is returned. 
                         
                         If the Deque has only one item remaining a Line with the status LINE\_EMPTY is returned. 
                         This is tested before the top\_mutex is locked in order to avoid unnecessary blocking of the pop\_bottom operation.
                         In any other case an attempt to lock the top\_mutex is made. If this fails then a simultaneous pop\_bottom operation
                         has locked the deque item, and a Line with the status LINE\_ABORT is returned. 
                         Otherwise the item at the top of the Deque is returned and the top counter is incremented.

\item \textbf{de\_push\_bottom: } \\
                         Accepts a Deque pointer and a Line to push onto the bottom of the queue. 
                         
                         It attempts to re-size the array (if it needs to) and increments the bottom counter whilst placing the 
                         Line passed to it on the bottom of the deque.
\end{itemize}

% the three operations and lock
Both the de\_pop\_bottom and de\_steal operations, in some situations, need to ensure that the thread has exclusive access of the 
top index of the deque.
This is achieved using the pthread\_mutex\_trylock function, which accepts a mutex and returns \textit{0} should lock be successful.
Otherwise, for instance when the mutex is locked by another thread, an error value is returned. This allows the thread to test the 
state of the mutex, and continue execution without blocking (waiting for the mutex to become un-locked).

\begin{lstlisting}[label=li:destrealtrylock,
caption=This excerpt taken from the code for the de\_steal operation shows how the pthread\_mutex\_trylock funciton is used to avoid blocking when the mutex is already locked. If the function returns \(0\) the mutex is available otherwise the else clause is taken.]
if( pthread_mutex_trylock(&d->top_mutex) == 0)
{
    l = d->queue[d->top % d->mem_size];
    d->top++;
    pthread_mutex_unlock (&d->top_mutex);
}
else{
    l = abort_steal;
}
\end{lstlisting}

This allows the thread to handle such a situation accordingly; in the case of the steal operation an abort signal, and in the case
of the pop operation an empty signal. An empty signal is produced here because the only situation where a de\_steal operation will block 
a de\_pop\_bottom operation is when there is only one item remaining in the deque, which has already been claimed by the steal operation.
The benefit of using this approach, rather than a pthread\_mutex\_lock based method, is that \gls{dead-lock} is avoided.

\subsubsection*{The Circular Array}

\input{circ}

% cicular array
The deque makes use of a \gls{circular array} which automatically grows and shrinks.
This approach is memory efficient and intuitive. 
It also allows for the top counter to remain unchanged unless a steal operation occurs (in most cases), reducing the frequency of locks occurring.
Figure \ref{fig:circ-demo} illustrates some of its mechanics. For instance figure \ref{fig:circ-5} shows that the array is indeed circular, in that it
``wraps around" when the final element is reached and there are elements un-used at the start.

The design relies on bottom and top counters (used to index the array), the memory-size (the number of memory slots allocated to the deque), and 
the size (the number of elements which are currently used). The size is computed by subtracting the top counter from the bottom counter. 
This is used to detect an empty array, and detect when the array needs to be re-sized.
When the array is accessed, the correct element is indexed by computing \(realindex = index \bmod memorysize \). 
For example, let the top counter equal fifteen and the memory-size equal ten, the \(realindex\) of the top element is five.
This allows for the top and bottom counters to exceed the memory size and still point to the correct index, without allowing access to memory outside the 
bounds of the array. It also maintains that the size can be computed correctly. When the array becomes empty the counters are re-set to zero.

Should the size exceed the memory-size, the array is automatically re-sized by double its current allocation. 
This is achieved by allocating a new array using malloc, copying the contents of the old array then freeing it, 
then assigning a pointer to the new array to the deque. 
Similarly, the array is shrunk by half when its size recedes to half of the memory-size using the same approach.
The consequence of this design is that the top\_mutex must be locked throughout any re-size operation, blocking any de\_steal
attempts until the mutex is un-locked. 
The benefits of this approach are that the deque is more scalable, and only memory that is likely to be used is allocated.
Rather than some amount that is defined at compile-time.

\subsection{The Work-Stealing Mechanism}

The design described here utilises the deque implementation to produce an effective work-stealing scheme.
The algorithm is so called `randomised' because of the means to which a victim is selected.

\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{wsthreadactivity}
% full caption
\caption{
An activity diagram to describe the behaviour of a work-stealing thread which utilises 
the double ended queue outlined in section \ref{sec:dequeimp}. 
\(L\) is the line popped from the threads deque. 
\(SL\) (stolen line) is the line popped from the victim's deque.
The \(victimsize\) is the is the amount of work currently in the victim's deque.
The \(stealquota\) is the amount of work items to be stolen.
The \(fillcount\) is the number of items that have been stolen so far.
The \(failcount\) is the frequency of failed steal attempts.
}
\label{fig:wsthreadactivity}
\end{figure}

% 4 key functions: 
% * ws\_worker\_thread
% * ws\_compute\_deque
% * ws\_become\_thief
% * ws\_victimise

\begin{itemize}
\item \textbf{ws\_worker\_thread: } \\
                The function which is passed to pthread\_create. This acts as the point of entry for each \gls{thread}.
                It accepts a pointer to the deque which is associated with the given thread. This is passed 
                in the form of a void pointer which has to be cast due to the interface provided by the pthreads
                library.
              
                This function makes use of a do-while loop which breaks when there is no work remaining in any \glspl{worker-thread} \gls{ready-deque}. 
                Each iteration of the loop sets the thread to work by calling the ws\_compute\_deque function, which returns when 
                no work remains in the \gls{ready-deque}. Then, the thread becomes a \gls{thief} and must attempt to acquire work
                from other threads by calling ws\_become\_thief. If more work is acquired the thread becomes a worker and calls ws\_compute\_deque
                again. If no work is found the conditions of the loop are broken and the thread exits.
              
\item \textbf{ws\_compute\_deque: } \\
                Accepts a Deque pointer, i.e. to the Deque associated with the same thread. This function 
                calls de\_pop\_bottom until it detects that the ready-deque is empty, at which point it returns
                the total number of work items completed for this call.
                
\item \textbf{ws\_become\_thief: } \\
                This operation randomly selects a thread to victimise. If it detects that there is no work
                available to steal it returns 0, otherwise it returns 1.
                It accepts a Deque pointer to the Deque associated with the same thread. 
                
                When a victim is selected the ws\_victimise function is called.
                
                In order to determine that no work is available, a set to mark each thread which is unsuccessfully victimised (referred to as
                the exclude set), as-well as a counter is maintained.
                The exclude set is initialised by adding the current thread. It is passed to ws\_random\_deque which
                uses the standard c rand function to generate a number between zero and the number of threads, used to access an array 
                of deques indexed by thread id. The randomly selected deque is returned.
                
                The function expects the exclude set to have at-least one element which is not a member.
%                When the counter is equal to the number of threads, one is returned indicating that no work is available.
                
\item \textbf{ws\_victimise: } \\
                Accepts deque pointers for the thief and victim threads. This function is responsible for the attempted migration of half the victims 
                workload, to the deque of the thief thread. It returns zero for an unsuccessful victimisation and one for success.
                
                The initial line is acquired by calling de\_steal on the victim. If the line has the status LINE\_EMPTY zero is returned. 
                Otherwise the victim has work to be stolen, so its work-count is evaluated and halved to determine how many work items the thief
                can attempt to steal.
                The initial line is pushed onto the thief's deque and the next line is stolen, providing the fill\_count (the counter which
                tracks how much work has been stolen) has not exceeded the allotted amount of work to be stolen. Otherwise one is returned.
                The fill\_count is then incremented. 
                The line is checked for the LINE\_ABORT status. If this is true de\_steal is called again.
                Otherwise this entire process is repeated until the LINE\_EMPTY status is received, or the allotted amount of work is stolen.
\end{itemize}

\subsubsection*{Problematic Characteristics}

This scheme allows for multiple threads to perform work-stealing operations simultaneously. 
Due to the random nature of victim selection, some problematic situations may arise at run-time.
These situations are likely to be detrimental to the overall balance of work load.
They are described as follows:

\begin{itemize}
\item \textbf{Double Victimisation:} \\
        Where two threads concurrently victimise the same thread.
        In this situation more than half of a victims deque is migrated.
        It can result, under certain circumstances,
        in almost all of the work in a victims deque being re-distributed in quick succession. 
        
        This is problematic because it can force unnecessary migration of work, which subsequently results 
        in more frequent steal operations.
        
        Figure \ref{fig:doubvict} illustrates this phenomenon.
\item \textbf{Victimisation of a Thief:} \\
        When a thief is selecting a thread to victimise it does not discriminate between working threads 
        and thief threads. Thus a `sub-thief' can steal work from a thread which is already stealing work from a 
        victim.
        
        In this situation work is indirectly moved from a victim to the sub-theif, via 
        another threads deque. The problem is the size of a thief thread's deque, does not equal 
        the total number of stolen items until all items are migrated. As a result the sub-thief 
        effectively steals less than half of the thief's eventual workload, as it evaluates its size
        before all items are transferred. 
        This could result in an unfair re-distribution of work, and ultimately an unbalanced work load.
        
        The diagram in figure \ref{fig:victtheif} represents such a situation.
\end{itemize}

Both problems could potentially be mitigated by making work-stealing operations atomic using mutex locks. 
In practice this involves implementing a mechanism where a thread can only take the state of either worker, thief, or victim
at any given time, where thieves may only victimise workers. 
This would come at the cost of blocking execution of a thread in certain cases, and would add to the complexity of the algorithm.

\input{problemsit}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Additional Schemes}
\label{sec:addscheme}

This section describes three additional modules which make use of different alternative 
approaches to that described in section \ref{sec:randws}. 
They interface with the Mandelbrot module in the same fashion as described in section \ref{sec:mandmod}

These schemes primarily serve as a benchmark for the randomized work stealing algorithm, but also 
serve to verify the Mandelbrot module.

\subsection*{A Sequential Algorithm}

This is the simplest algorithm presented and utilizes no concurrency.
It iterates each line (i.e. \(y\) index) of the raster plane in sequence, calling compute\_line for each value of \(y\).
This module effectively implements a variation of the level set algorithm described in listing~\ref{li:mandelalgo}
by adding the outer for loop of the compute\_mandelbrot function.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{seqactivity}
% full caption
\caption{
    An activity diagram which illustrates the simplicity of the sequential scheme.
}
\label{fig:seqactivity}
\end{figure}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection*{A Na\"{\i}ve Parallel Algorithm}

This scheme is a simple parallel algorithm. It is so called na\"{\i}ve because of its comparable unbalanced work distribution to
the a run-time work balanced algorithm. It is an example of a typical scheme used for composing a parallel program, based on a 
sequential implementation.

The raster plane is divided into equal regions, which each thread computes independently.
The regions are comprised of a set of contiguous \(y\) lines of the size \(height / threadcount\).
Each region is assigned as follows where \(ystart\) is the first and \(yend - 1\) is the last member of the region: 

\[regionsize = height / threadcount\]
\[ystart = threadid * regionsize\]
\[yend = (threadid + 1) * regionsize\]

For the region with the thread id equal to \(threadcount - 1\) (i.e. the thread which computes the lower region) 
\(yend = height\). This is to ensure that all lines are assigned when \(height\) is not integer divisible by \(threadcount\).
This functionality is omitted from figure \ref{fig:naiveparactivity} as not to muddy the simple, demonstrative purpose of the diagram.

Figure \ref{fig:naiveparactivity} illustrates how the design of the sequential version, documented in 
figure \ref{fig:seqactivity}, is composed onto multiple threads to attain a parallel design.
This is done by introducing a fork point, which starts the threads, and a join point which 
returns program control to the main execution flow.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{naiveparactivity}
% full caption
\caption{
    An activity diagram which illustrates the use of simple multi-threading employed by this 
    scheme. It is worth noting that the dashed lines near the fork and join bars 
    are added to illustrate that more than one thread executes simultaneously.
}
\label{fig:naiveparactivity}
\end{figure}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection*{A Render-Thread Work-Stealing Algorithm}
%to cover:
% * algorithm architecture: i.e. render threads, monitor thread.
% * Describe a steal operation.
% * Talk about initial distribution of work.
% * Talk about estimated completion time.

This scheme implements the approach described in the background research section \ref{sec:rendscheme}. 
One monitor thread and three worker-threads are used. 

The monitor thread is delegated the responsibility 
of controlling steal operations, and synchronising the thief and victim threads in order to complete
this operation.
Each render thread computes its work-load until it has no more to do. At this point it produces a thief
signal which the monitor thread detects. 
A worker thread can be made a victim while it is working. It is allowed to finish its current line 
before becoming a victim.

The expected completion time of a render thread is evaluated to determine a victim. This means 
such a metric needs to be maintained, and regularly updated, in order to make this approach fair.
The time taken to complete a work item is multiplied by the amount of work remaining for that thread. 
This is re-calculated after each line is computed.

Figure \ref{fig:rtdiagram} shows a graphical representation of a typical, happy-day scenario steal operation. 
It highlights the amount of inter-thread communication which occurs in order to complete such an operation.  

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{rtdiagram}
% full caption
\caption{
    A diagram which illustrates a typical steal operation for the Render-Thread Algorithm. 
    It illustrates how steal operations require thread synchronisation.
    Grey shaded boxes, with dashed borders, represent 
    regions of time in which the corresponding thread must wait for a signal. White boxes indicate that a thread 
    is performing some task. Arrows between threads indicates inter-thread communication.
}
\label{fig:rtdiagram}
\end{figure}

This approach blocks working threads in order to achieve work-stealing. This comes with the added complication
that such a scheme needs to be carefully designed in implementation. 

% TODO explain why some of this design is bad news

Unfortunately, due to time constraints, there is no fully complete implementation for this scheme in place.
It is worth noting that this area alone is a significant body of work, and represents a good portion
of the future work this project could lead to. 

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Output}
\label{sec:output}

The system is capable of outputting PPM image files of the computed raster plane. 
This can be enabled using command line options described in section \ref{sec:userint}.
Output is made optional because the process of producing the file is computationally time 
consuming, especially for large raster planes. It contributes to the code which 
cannot be parallelised.

\input{outmode}

\subsection*{Output File Format}

The specification for the PBM, PGM, and PPM formats is presented here \cite{ppmspec}.

Each file contains data for one image presented in plain text. This consists of some header information, 
followed by an entry for each pixel. 

The header consists of four fields. On line one the `magic number' determines the colour style used.
P1 is used for monochrome (PBM), P2 for grey-scale (PGM), and P3 for colour (PPM).
On line two is the width and height as decimal numbers, separated by a space.
On line three is the maximum colour value a pixel can be. For the PBM format this line is omitted.
Each line is separated with a carriage return. 

Pixel data is separated by spaces and arranged in lines ending in a carriage return. 
Each line has exactly \(width\) entries and their are exactly \(height\) lines.
For the PPM format each pixel has three entries representing red, green, and blue.

\input{ppmformat}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Run-Time Tracing}
\label{sec:traceimp}

A simple tracing mechanism is implemented allowing for run-time analysis of implemented scheduling modules.
Any trace related code is not compiled by default, as it has a detrimental effect on performance. 
Instead an option must be passed to `make' when the project is built to enable tracing.

Related code is encased in preprocessor directives as follows:

\begin{lstlisting}
/* Tracing for all modes */
#ifdef TRACE
...
trace_event("mode 1: %",123);
#endif

/* Mode specific tracing code */
#if TRACE == 2
...
trace_event("mode 2: %d",456);
#endif 
\end{lstlisting}

The trace\_event function prints a time-stamp in microseconds relative to the start of execution,
followed by the desired message. A \gls{mutex} is locked to ensure each output message
is completed and written in sequence.

Currently two modes are in place.
These can be built by passing the following arguments to `make':
\subsubsection*{TRACE=1}
            A completion message is printed when the scheduling module has completed execution.
            This serves as a means of measuring the execution time of the program as a timestamp
            relative to the start.
            
\begin{lstlisting}
499066: complete
\end{lstlisting}


\subsubsection*{TRACE=2}
            Traces thread activity in scheduler modules. 
            All thread related traces specify a thread id using the T\_id field.
            The following example shows a trace of the na\"{\i}ve parallel algorithm.
            
\begin{lstlisting}
242: T_id 1 started
...
754652: T_id 1 finished computing 1250 lines
...
754804: complete
\end{lstlisting}

\subsection*{Tracing the Randomised Work-Stealing Algorithm}

The trace format for the Randomised Work Stealing algorithm requires some explanation.
It is detailed as follow:
\\

\begin{lstlisting}[label = ls:wstraceeg,caption = Examples of the Four Traced Events for the Randomised Work-Stealing Scheme]
1316: T_id 0 started
...
396334: T_id 0 steal vi: 3, ws: 10
...
1948938: T_id 3 ret-work fc: 1
...
1960169: T_id 3 finished li: 3237, sc: 4, vc: 4
\end{lstlisting}

\begin{itemize}
\item \textbf{started:} \\
        The thread specified by the T\_id field has started. Line one of listing \ref{ls:wstraceeg} shows an example.

\item \textbf{steal:} \\
        The thread specified by the T\_id field has successfully performed a steal
        operation. The vi (victim) field indicates the thread id of the victim and ws (work stolen) field shows
        the quantity of work items migrated. Line three of listing \ref{ls:wstraceeg} shows an example.

\item \textbf{ret-work:} \\
        The thread specified by the T\_id field has finished stealing work and is returning to compute its stolen 
        lines. The fc (fail count) field shows how many times the thread victimised another unsuccessfully. 
        Line five of listing \ref{ls:wstraceeg} shows an example.
        
\item \textbf{finished:} \\
        The thread specified by the T\_id field has detected no available work and has fineshed. The li (lines) fields shows the
        quantity of work items computed, the sc (steal count) field shows how many successful steal operations the thread carried out, 
        and the vc (victimisation count) field indicates how many times the thread was victimised.
        Line seven of listing \ref{ls:wstraceeg} shows an example.
        
\end{itemize}

Some examples of full run-time traces are available in the appendices section \ref{sec:traceout}.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{User Interface}
\label{sec:userint}

A basic command line interface is implemented which offers a few options to control the output of the program.
When the program is given no arguments it computes the mandelbrot set with no output.
The available options are described in the following paragraphs.

\subsubsection*{-{}-outmode=\textless mode\textgreater}

Determines the appearance of the output PPM file.
The mechanism for producind output is described in section \ref{sec:output} and
examples of each mode are shown in figure \ref{fig:outmodes}.
There are three possible modes implemented:
\begin{itemize}
\item \textbf{greyscale}
            Gradient of black to white. 
\item \textbf{redscale}
            Gradient of black to red.
\item \textbf{distribution}
            Each thread is represented by a different gradient.
\end{itemize}

This option must be used in order for output to occur.

\subsubsection*{-{}-outfile=\textless file\textgreater}

This option is used to specify the name of the output file.
It must be used in conjunction with the `outmode' option.
If this option is omitted the output file takes the default name `out.ppm'.

\subsubsection*{-{}-help}

Displays a usage message which describes the options detailed above.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
%\section{Validation and Verification}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Discussion and Evaluation}
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Analysis of the Implemented Algorithms}
\label{sec:analysis}

This section discusses some observations made based on results gathered over a series of program runs.
It also serves to asses the validity of the implemented schemes, ensuring that the code does what is expected.

\subsection{The Test Setup}

Here is a brief description of the environment used when gathering the results to support this section.

% TODO: Get PC specs from home.
\subsubsection*{Test System}
\begin{itemize}
\item CPU: Quad Core Intel Core I5
\item Memory: 8GB DDR-3
\item Operating System: Linux Mint 14
\item C-Compiler: GCC Version ...
\end{itemize}

\subsection{Performance Analysis}

The following observations relate to performance of the implemented schemes.
The collected performance data, for both figure \ref{fig:perfmatsizepc} and \ref{fig:perfworksizepc},
are calculated using an average time of five runs of the labelled version of the program per plot.
These are presented in relation to the sequential version of the program. 

The following equation is used to calculate the performance increases presented:

\[ RelativePerformance_a = \frac{ExecutionTime_a}{ExecutionTime_{sequntial}}\]

\begin{itemize}
\item Figure \ref{fig:perfmatsizepc} suggests that the Randomised Work-stealing Algorithm scales as 
      well as the na\"{\i}ve Parallel Algorithm. 
\end{itemize}

\input{pcmatsize}
\input{pcworksize}

\subsection{Analysis of the Randomised Work-Stealing Algorithm}

\subsubsection*{Run-Time Analysis}

The scatter plot shown in figure \ref{fig:tracelap1} and the bar charts shown in figure \ref{fig:stealvictbar} 
bring to light some interesting properties of the algorithm.
They also highlight some potential points of improvement.
\\

\input{laptrace-stvti}

The following observations are based on the results presented in figure \ref{fig:tracelap1}:

\begin{itemize}
\item 
    As less work items are available, steal-operations become more frequent, in which fewer work items are migrated. 
    This trend continues until no work items are available and completion is detected, as is suggested by the data.

    The result is that a high frequency of steal operations, where small amounts of work are
    migrated, occur as processing nears termination. The benefit of migrating such small work-loads could
    be seen to outweigh the cost of allowing the thread to continue computing the given region.
    
    This could be alleviated by implementing a work migration threshold, which limits a steal operation 
    to a minimum number of steal-able work. Should the projected work-load to be migrated fall under 
    this threshold, the steal attempt would fail. 

\item 
    A situation where multiple threads perform a steal operation in close time proximity arises often.
    Five clear examples of this are exposed at approximately \(0.4\),\(1.4\),\(1.6\),\(1.8\), and \(1.9\) seconds.
    This outweighs the three instances in which a single steal operation occurs within \(0.1\) of a second.

    The following trace excerpt corresponds to the data shown in the plots marked in black. 
    It details the three points plotted at approximately \(1.6\) seconds.

\begin{lstlisting}
...
1625982: T_id 0 steal vi: 1, ws: 429
1626009: T_id 3 steal vi: 1, ws: 214
1628855: T_id 2 steal vi: 3, ws: 106
...
\end{lstlisting}
    
    This example highlights some possible instances of the problematic situations detailed in section \ref{sec:randws}. 
    
    A double victimisation is present where both thread zero and three steal from thread one. Notably thread three 
    migrates roughly half the work items thread zero does. This suggests that thread one's work load has been reduced
    by nearly three quarters in quick succession.
    
    In addition, closely after, thread two victimises thread three. This suggests that victimisation of a thread has occurred,
    and again the transferred work-load is approximately half that stolen by the victim. It implies that work has indirectly 
    been moved from thread zero, to thread two, via thread three.
    
    This behaviour is a side effect of using a randomised approach to victimisation. Other approaches, for example evaluating work
    throughput metrics, could alleviate these problems.
\end{itemize}

\input{laptrace-st-vi}

The following observations are based on the bar charts presented in figure \ref{fig:stealvictbar}:

\begin{itemize}
\item 
    Each thread is victimised on average \(3.275\) times over twenty program runs. 
    The lowest average victimisation count is \(2.9\) (for thread zero) and the highest is \(3.75\) (for thead one).
    These results, which are visualised in figure \ref{fig:barstvvi}, suggest that randomly selecting a victim 
    thread to steal from is a relatively fair mechanism.

    It is worth noting that this is dependant on the qualities of the random number generator function.
    This implementation uses the `rand' function provided the `stdlib' library with a static seed. This is done to 
    produce more repeatable behaviour. 
    A more effective approach may be to produce a random function in which the seed is based on a dynamic system property,
    for instance the clock time. 

\item 
    The threads which are initially assigned the upper and lowermost quarters of the raster-plane compute, on average, roughly three times 
    more work items than the inner threads. 
    This demonstrates that the algorithm implicitly balances work-load at run-time, and is shown in figure \ref{fig:stealvictbar}.
    
    The behaviour exhibited here is expected as the majority of the computational load lies in the central regions. 
    Put more concisely; when a point is deemed a member of the set, exactly the maximum number of iterations will have occurred, thus 
    involving more work. In general, the closer a point lies to the set, the more costly it becomes to process.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|r|}
        \hline
            \textbf{Thread ID} & \textbf{Completion Time} (\(\mu\)secs) \\
        \hline \hline
            \textbf{0} & 410922 \\
            \hline
            \textbf{1} & 3001814 \\
            \textbf{2} & 2956266 \\
            \hline
            \textbf{3} & 432267 \\
            \hline
    \end{tabular}
    \label{tab:npartab}
    \caption{The time taken from thread start to finish, for each thread in the na\"{\i}ve parallel algorithm to compute its assigned region.
The data presented here is sourced from the trace presented in appendices figure \ref{apptracens}.}
\end{table}

    As the rendering of the set has symmetry on the horizontal axis it is expected that each half should represent an equal 
    proportion of the work-load. 
    This can be illustrated by analysing a trace of the na\"{\i}ve parallel algorithm. Table \ref{tab:npartab} shows that the 
    central regions take longer to compute when no run-time load balancing is employed.
    
    Split into four initial, equally sized regions the randomised work-stealing algorithm should ideally redistribute work 
    to alleviate the exhibited behaviour of the na\"{\i}ve-parallel algorithm.
    For the outermost regions (i.e. threads zero and three) this is true, as can be seen in figure \ref{fig:stealvictbar},
    where these ultimately compute approximately the same proportion of the plane.
    However, a discrepancy arises for the innermost threads (one and two) where thread one, on average, computes much fewer lines
    than its counterpart two. 

    This could be attributed to a number of aspects of the design. For instance, the phenomena of double victimisation and 
    victimisation of a thief could be responsible for the unfairly balanced work load. Further investigation is
    required to determine a more evident cause.
        
\end{itemize}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Reflection}

In general, the author feels that this project is a successful one. It has been an enlightening and thoroughly enjoyable experience
to investigate the subject area. Here is an evaluation of each objective defined in the introduction section, as well as some aspects 
of the project which apply in general.

% TODO complete these sections!!!!!
\subsection{Core Objectives}
\subsubsection*{Background Research}
    Background research is presented in chapter \ref{ch:backres}. To start; a broad range of areas related to scheduling parallel algorithms is explored 
    and explained. The work-stealing approach is introduced here, however the discussion is further developed in section \ref{sec:resworkdepth}. 
    A concise explanation of the Mandelbrot set, and its surrounding themes, is offered between these. 
    Finally, an overview of considered tools is added to show the extensive range of relevant development resources available.
    
    The studied areas provide the reader with a sufficient overview of the themes explored in the main project. To further 
    bolster the readers understanding, a glossary of terms is presented in appendix \ref{sec:glosterm}. 
    This gives a brief definition for some of the major concepts discussed which go slightly beyond the scope of this body of work.
    
\subsubsection*{A Sequential Mandelbrot Set Algorithm}
    Although the sequential algorithm described in section \ref{sec:addscheme} appears trivial, it relies almost entirely
    on the mandelbrot module described in section \ref{sec:mandmod}. This objective encompasses the implementation of this
    module, as this separation is derived from a sound design decision to encapsulate in order to reduce code complexity. 
    It also improves code re-usability, of which is exploited extensively elsewhere throughout the project. 
    
    This body of work also demonstrates good use of the C programming language.
    
    This objective is met with a high degree of quality, and forms a well-grounded foundation for the following objectives
    to build on.
    
\subsubsection*{A Na\"{\i}ve Parallel Mandelbrot Set Algorithm}
    A basic understanding of composing parallel programs is effectively demonstrated by completion of this objective.
    The described implementation in section \ref{sec:addscheme} shows effective use of the pthreads library and its functionality. 

\subsubsection*{A Random Work-Stealing Mandelbrot Set Algorithm}
    This objective forms a significant proportion of the work carried out during this project. It is the central focus of the 
    project and exhibits more advanced programming and design techniques. 
    This is described in great depth in section \ref{sec:randws}.
    
    The implemented scheme demonstrates a strong grasp of concepts discovered through research of the subject area (see section \ref{sec:resworkdepth}),
    and utilises these in a proficient and competent fashion. The design is both elegant and simple, as-well as effective in practice.
    Some advanced techniques demonstrated here include; production of a non-blocking double ended queue, use of more pthreads mutex locks, and
    design of a sophisticated work-load balancing algorithm.

    Constructive criticism of the scheme is also offered, giving commentary on the implications of certain properties and possible
    remedies for problematic behaviour.
    
    Overall, this portion of the project represents the majority of the technical and theoretical learning achievements made.
    
\subsubsection*{Analysis of the Implemented Algorithms}
    Technical analysis of the end product is offered in section \ref{sec:analysis}.
    Observations made, based on data collected from traced run-time activity, are offered.
    
    These provide some insight into the performance of the end product, as well as some explanation for
    undesirable behaviour.

    This assesses how effective the randomised work-stealing algorithm is and identifies room for improvement.
    It also serves as validation to show that the product does what is intended, as well as to verify that it functions correctly.

\subsection{Advanced Objectives}
\subsubsection*{Graphical Output}
    The program produces output images in various styles. These are detailed in section \ref{sec:output}.
    This proves that the product produces a correct approximation of the mandelbrot set (seeing is believing) and, in the 
    case of distribution mode, gives evidence of the work-stealing algorithm's effectiveness. 
    
    The image format used is text based, thus inefficient and slow to write. The solution used to achieve this objective is basic, but serves 
    the purpose.
    
\subsubsection*{A Render Thread Work-Stealing Mandelbrot Set Algorithm}
    This objective is incomplete as of the compilation of this report. 
    Areas explored in an attempt to complete this additional objective include
    a design for the scheme, and a working but unstable implementation.
    
\subsubsection*{Work-Stealing Trace System}
    This objective is completed and provides an effective means for gathering 
    and analysing run-time characteristics of an implemented scheme.
    
    Although the objective is met a number of improvements could be made to record 
    a more detailed set of information. 

\subsection{Other Notable Points of Reflection}
\subsubsection*{Project Management}
    The major objectives for this project where completed comfortably in the time-scale provided.
    These achievements roughly correspond with the planned time allocation described in the Gantt chart
    provided in the detailed project proposal.
    
    A major factor which streamlined the entire process is the decision to use a Git repository.
    It provided a vital means of tracking progress through regular commit messages and the ability
    to easily revert back to more old revisions. All the work related to this project can be found 
    here: \textit{https://github.com/mhawes/wstealmandel}.

\subsubsection*{Professional Presentation of Material}
    All material delivered in a highly professional manner.
    
    In particular, the decision to produce this entire report using \LaTeX~has been pivotal
    to the clarity and good structure of this report. It has also provided the learning outcome 
    of acquiring proficient skill when using the language, which will be taken forward to future projects.

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Further Work}

Although the core project objectives have been completed, as well as the majority of the additional objectives, 
there are a number of interesting areas in which this work could be extended.

Some of these suggestions could form whole BSc Computer Science projects in their own right. The author hopes they 
may at least invoke some inspiration for those planning to embark on such a task.

\subsubsection*{Alternative Work-Stealing Schemes and Policies}
To further investigate the work-stealing approach un-explored configurations could be implemented. 
Areas which could be examined include:
\begin{itemize}
\item \textbf{Different Victimisation Policies: } 
    Techniques for selecting a victim, for example choosing the thread which has the lowest work-throughput, could 
    prove to more-fairly balance work-load. This would also serve as a point of comparison for the randomised approach.
\item \textbf{Threshold Stealing: }
    By enforcing a minimum limit for the amount of work a thief can steal, a number of unnecessary steal operations could be avoided.
\item \textbf{Alternative Deque Implementations: }
    The Deques implementation could be re-implemented using a different data structure design. For instance instead of a circular array,
    a linked list could be put in place.
\item \textbf{Different Multi-Thread Designs: }
    Other approaches to parallel algorithm design could applied to produce other, perhaps more intuitive, designs.
    A fully working implementation of the Render-Thread scheme would be a good starting point for this line of enquiry.
\end{itemize}

\subsubsection*{Computing Julia Sets}
The existing code in the Mandelbrot module could be fairly easily adapted to support raster-plane generation for Julia sets.
The algorithm could accept a parameter to specify the value of \(z\) for the function described in equation \ref{eq:julia1}.
This would expose a huge set of new test cases for the randomised work-stealing algorithm implementation.

\subsubsection*{Investigate Specific Multi-Processor Architectures}
Parallel computing platforms such as cluster computing, cloud computing, cellular architectures, amongst many others 
geared toward high performance computing, would be a relevant  area for further study. 

By focusing on a particular class of architecture the algorithm could be optimised, taking into consideration such 
properties as cache and memory layout, locality of related work-items, and processor locality. 

\subsubsection*{Development of A Parallel Programming Library}
The themes explored in this report could be applied to a vast number of programs. 
Producing a library which provides abstract programming directives, such as parallel data-structure iterators, or
support for fully strict multi-threaded computations, could prove a useful general programming tool. 

\subsubsection*{Expansion of the Capabilities of the Tracing Mechanism}
A more concise tracing system could be implemented. The current mechanism provides only very limited run-time information
of the implemented algorithms. 
Features to calculate statistics such as work item throughput per thread, detection of detrimental situations, and running 
tallies of thread status are desirable. These could provide vital debugging tools and could help to identify detrimental 
properties of the algorithm.

\subsubsection*{More Efficient Image Generation}
Currently the output image takes a noticeably long time to write. This is due to the nature of the file format used.

The program could be adapted to use a run-time graphics library, such as OpenGL, to display the image as it is generated.
In adition, this could be used to illustrate the work-stealing scheme in action. As each thread completes a work item its corresponding
line would appear on the screen in its assigned colour gradient. This would show how work items are migrated throughout runtime and serve
to demonstrate the workings of the algorithm.

\section{Conclusion}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Resources}
% refs\bibs:
\nocite{*}
\bibliography{refs}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------------------------------------------------------------------------------------

\chapter{Appendices}
\appendix

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Glossary of Terms}\label{sec:glosterm}
%\glsaddall
\printglossaries

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\newpage
\chapter{Source Code}\label{sec:srccode}

% ---------------------------------------------------------------------------------------------------------------------------------------------------------------
\newpage
\chapter{Trace Output}\label{sec:traceout}
\input{append/traces}

\end{document}
